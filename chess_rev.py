# -*- coding: utf-8 -*-
"""四子棋-allrule.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VHEcKPGklF6NnWQkPc-LD-TayQ0ri4ZJ
"""

import numpy as np
import matplotlib.pyplot as plt
import random



#Train
Mset=[] #盤面
Wset=[] #盤面勝負
train_time=0  #train的次數

Mset_ = np.load(r'Mset161113.npy')
Wset_ = np.load(r'Wset161113.npy')

for arr in Mset_:
    Mset.append(arr)

for num in Wset_:
    Wset.append(num)
    
train_time = len(Mset)

print(train_time)

def next(N, row, col, x, y, val):
    if ((N[row][col]==N[row+x][col+y])and (val<4)):
        val+=1
        #print(row)
        #print(col)
    else:
        return 1
    return 1+next(N, row+x, col+y, x, y, val);

def Check_win(N, row, col):
    ans = 0
    A = np.zeros((8, 9))
    for ii in range (0, 6):
        for jj in range (0, 7):
            if (N[ii][jj]==0):
                pass
            elif ((N[ii][jj]%2)==0):
                A[ii+1][jj+1]=-1
            else:
                A[ii+1][jj+1]=1
    #print(A)
    #print(A[row-2:row+2, col+1])
    if(row>=3):
        if (abs(np.sum(A[row-2:row+2, col+1]))==4):
            ans=1
            
    count=next(A, row+1, col+1, 1, 1, 1)+next(A, row+1, col+1, -1, -1, 1)-1
    #print(next(A, row+1, col+1, 1, 1, 1))
    #print(next(A, row+1, col+1, -1, -1, 1))
    if (count>=4):
        ans=1
    count=next(A, row+1, col+1, 1, -1, 1)+next(A, row+1, col+1, -1, +1, 1)-1
    if (count>=4):
        ans=1
    count=next(A, row+1, col+1, 0, 1, 1)+next(A, row+1, col+1, 0, -1, 1)-1
    if (count>=4):
        ans=1
        
    return ans

def True_false(N,last):
    a=[]
    b=[]
    c=[]
    A=N
    for jj in range(0,7):
        k=0
        for ii in range(0, 6):
            if(N[ii][jj]==0):
                a.append(ii)
                k=1
                break;
        if(k==0):
            a.append(-1)

    for ii in range(0,7):
        #print('aaa',a[ii],ii)
        if (a[ii]>=0):
            A[a[ii],ii]=last+1
            if (Check_win(A, a[ii],ii)==1):
                b.append(ii)
                #print(ii)
            A[a[ii],ii]=0
        #print(A)
        
    #print("end1")
    if (b==[]):
        for ii in range(0,7):
            if (a[ii]>=0):
                A[a[ii],ii]=last+2
                    #print(A)
                if (Check_win(A, a[ii],ii)==1):
                    b.append(ii)
                    #print(ii)
                A[a[ii],ii]=0
    #print("end2")
    for ii in range(0,7):
        if(a[ii]>=0) and (a[ii]<5):
            A[a[ii],ii]=last+1
            A[a[ii]+1,ii]=last+2
            #print(A)
            if (Check_win(A, a[ii]+1,ii)==1):
                c.append(ii)
                #print(ii)
            A[a[ii],ii]=0
            A[a[ii]+1,ii]=0
    if b==[]:
        b.append(-1)
    if c==[]:
        c.append(-1)
    #print(b)
    #print(c)
    return([b,c])

def Point_to_col(p_,TF):
    p=[]
        
    for ii in range(len(p_)):
        if p_[ii]<0:
            p.append(0)
            #p.append(p_[ii])
        else:
            p.append(p_[ii])
    count_=0
    for ii in range(len(p)):
        if p[ii]!=0:
            break
        else:
            count_=count_+1
    max_=max(p)
    min_=min(p)
    #alpha is the basic wieght
    if count_==len(p_):
        alpha=1
    else:
        alpha=1/(max_-min_)
    grade=[]
    final_result=[]
    dont_put=[]
    
    
    for ii in range(len(p)):
        if count_==len(p_):
            grade.append(1)
        else:
            grade.append(alpha+3*(p[ii]-min_)/(max_-min_))
    
    if TF[0][0] != -1:
        for ii in range(len(TF[0])):
            final_result.append(TF[0][ii])
            grade[TF[0][ii]]=0

    
    if TF[1][0] != -1:
        for ii in range(len(TF[1])):
            grade[TF[1][ii]]=0
            dont_put.append(TF[1][ii])
    
    while sum(grade)!=0:
        
        pool=sum(grade)
        ball=pool*np.random.rand()

        count=0
        path=0
        for ii in range(len(grade)):
            if grade[ii]==0:
                path=path+1
            else:
                count=count+grade[ii]
                if ball<=count:
                    #print(ball,grade,path)
                    final_result.append(path)
                    grade[ii]=0
                    break
                else:
                    path=path+1
        
    for ii in range(len(dont_put)):
        final_result.append(dont_put[ii])
    
    return final_result

def Check_same_1(j,N):
    result = np.nonzero(N)
    for _ in range(len(result[0])):
        if((Mset[j][result[0][_]][result[1][_]] - N[result[0][_]][result[1][_]])%2 !=0 or Mset[j][result[0][_]][result[1][_]]>len(result[0]) or Mset[j][result[0][_]][result[1][_]]==0):
            return 0
    return 1

def Check_same_2(j,N):
    result = np.nonzero(N)
    for _ in range(len(result[0])):
        if((Mset[j][result[0][_]][6 - result[1][_]] - N[result[0][_]][result[1][_]])%2 !=0 or Mset[j][result[0][_]][6 - result[1][_]]>len(result[0]) or Mset[j][result[0][_]][6 - result[1][_]]==0):
            return 0
    return 1

def Compute_point_1(N,ii):
    result = np.zeros((7,2))
    #print(len(Mset))
    for j in range(len(Mset)):
        if(Check_same_1(j,N)): #check the first ii step is the same
            #print('Hello')
            next_step = np.where(Mset[j] == ii+1)
            if(len(next_step[0]))>0:  #data exist
                if(Wset[j]>0):
                  result[next_step[1][0]][0] +=1
                else:
                  result[next_step[1][0]][1] +=1

        if(Check_same_2(j,N)): #check the first ii step is the same
            #print('Hello')
            next_step = np.where(Mset[j] == ii+1)
            if(len(next_step[0]))>0:  #data exist
                if(Wset[j]>0):
                  result[6 - next_step[1][0]][0] +=1
                else:
                  result[6 - next_step[1][0]][1] +=1

    #for i in range(7):
      #print('past data: col_%d: pos: %d neg:%d ' %(i+1,result[i][0],result[i][1]))
    
    final = np.zeros(7)
    for i in range(7):
      final[i] =  result[i][0] - result[i][1]
    if(ii%2):
        final=-final
    
    return final

def Check_same_1(j,N):
    result = np.nonzero(N)
    for _ in range(len(result[0])):
        if((Mset[j][result[0][_]][result[1][_]] - N[result[0][_]][result[1][_]])%2 !=0 or Mset[j][result[0][_]][result[1][_]]>len(result[0]) or Mset[j][result[0][_]][result[1][_]]==0):
            return 0
    return 1

def Check_same_2(j,N):
    result = np.nonzero(N)
    for _ in range(len(result[0])):
        if((Mset[j][result[0][_]][6 - result[1][_]] - N[result[0][_]][result[1][_]])%2 !=0 or Mset[j][result[0][_]][6 - result[1][_]]>len(result[0]) or Mset[j][result[0][_]][6 - result[1][_]]==0):
            return 0
    return 1

def Compute_point_2(N,ii):
    result = np.zeros((7,2))
    #print(len(Mset))
    for j in range(len(Mset)):
        if(Check_same_1(j,N)): #check the first ii step is the same
            #print('Hello')
            next_step = np.where(Mset[j] == ii+1)
            if(len(next_step[0]))>0:  #data exist
                if(Wset[j]>0):
                  result[next_step[1][0]][0] +=1
                else:
                  result[next_step[1][0]][1] +=1

        if(Check_same_2(j,N)): #check the first ii step is the same
            #print('Hello')
            next_step = np.where(Mset[j] == ii+1)
            if(len(next_step[0]))>0:  #data exist
                if(Wset[j]>0):
                  result[6 - next_step[1][0]][0] +=1
                else:
                  result[6 - next_step[1][0]][1] +=1

    for i in range(7):
      print('past data: col_%d: pos: %d neg:%d ' %(i+1,result[i][0],result[i][1]))
    
    final = np.zeros(7)
    for i in range(7):
      final[i] =  result[i][0] - result[i][1]
    if(ii%2):
        final=-final
    
    return final

def Visual(N):
    NN=np.char.chararray((6,7), unicode=True)
    for u in range(0,7):
            for q in range(0,6):
                if N[q][u]==0:
                    NN[5-q][u]='*'
                elif N[q][u]%2==1:
                    NN[5-q][u]='o'
                elif N[q][u]%2==0:
                    NN[5-q][u]='x'                    
    return NN

import pygame

pygame.init()   
#screen = pygame.display.set_mode((1920, 1080)) # 顯示的視窗並設置視窗大小
screen = pygame.display.set_mode((0, 0), pygame.FULLSCREEN)
pygame.display.set_caption('四子棋遊戲') 
screen.fill((242, 242, 242))    # 設置視窗背景顏色

#難易度介面
font = pygame.font.SysFont("Times New Roman", 80)
text_6 = font.render("Difficulty Level", True, (0, 0, 0))
text_7 = font.render("Easy", True, (0, 0, 0))
text_8 = font.render("Medium", True, (0, 0, 0))
text_9 = font.render("Hard", True, (0, 0, 0))
screen.blit(text_6, (350,200)) #50 80
pygame.draw.rect(screen, (196,196,196), [140, 400, 180, 130], 0) 
screen.blit(text_7,(150,300+120))
pygame.draw.rect(screen, (196,196,196), [475, 280+120, 300, 130], 0) 
screen.blit(text_8,(490,300+120))
pygame.draw.rect(screen, (196,196,196), [900, 280+120, 180, 130], 0) 
screen.blit(text_9,(910,300+120))
pygame.display.flip()

Difficulty = -1
while(True): 
  event = pygame.event.wait()
  if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
    x, y = event.pos
    if 140<=x and x<=140+180 and 400<=y and y<=530 :
      Difficulty = 0
      Mset = Mset[0:50000]
      Wset = Wset[0:50000]
    elif 475<=x and x<=475+300 and 400<=y and y<=530 :
      Difficulty = 1
      Mset = Mset[0:100000]
      Wset = Wset[0:100000]
    elif 900<=x and x<=1080 and 400<=y and y<=530 :
      Difficulty = 2
      Mset = Mset
      Wset = Wset
  if(Difficulty != -1):
    break


screen.fill((242, 242, 242))    # 設置視窗背景顏色
pygame.display.flip()

#先後供畫面
font = pygame.font.SysFont("Times New Roman", 80)
text_1 = font.render("You want to go first?", True, (0, 0, 0))
text_2 = font.render("Yes!", True, (0, 0, 0))
text_3 = font.render("No!", True, (0, 0, 0))
screen.blit(text_1, (300,200)) #50 80
pygame.draw.rect(screen, (196,196,196), [370, 400, 180, 130], 0) 
screen.blit(text_2,(140+250,300+120))
pygame.draw.rect(screen, (196,196,196), [460+250, 280+120, 180, 130], 0) 
screen.blit(text_3,(490+250,300+120))
pygame.display.flip()

dice = -1
while(True): 
  event = pygame.event.wait()
  if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
    x, y = event.pos
    if 370<=x and x<=550 and 400<=y and y<=530 :
      dice = '0'
    elif 460+250<=x and x<=460+250+180 and 280+120<=y and y<=280+120+130 :
      dice = '1'
    
  if(dice != -1):
    break

screen.fill((242, 242, 242))    # 設置視窗背景顏色
pygame.display.flip()

#載入圖片
image_fox = pygame.image.load("amFox.png")
resized_image_fox = pygame.transform.scale(image_fox, [500,500])
resized_image_fox.convert()
screen.blit(resized_image_fox, (750,100))
#畫格子
rect_x_LU = 110
rect_y_LU = 120
rect_width = 80
circle_x_LU = rect_x_LU + rect_width // 2
circle_y_LU = rect_y_LU + rect_width // 2
circle_radius = rect_width // 2.5 - 1

for i in range(7):
  for j in range(6):
    for k in range(4):
      rect_x = rect_x_LU + rect_width*i
      rect_y = rect_y_LU + rect_width*j
      circle_x = circle_x_LU + rect_width*i
      circle_y = circle_y_LU + rect_width*j
      pygame.draw.rect(screen, (196,196,196), [rect_x, rect_y, rect_width, rect_width], 0) 
      pygame.draw.circle(screen, (242,242,242), [circle_x, circle_y], circle_radius, 0) 

#提示旗子
pygame.draw.circle(screen, (44,41,198), [150, 650], circle_radius, 0) 
pygame.draw.circle(screen, (205,39,45), [510, 650], circle_radius, 0) 
text_4 = font.render("You", True, (0, 0, 0))
screen.blit(text_4,(190,600))
text_5 = font.render("AI", True, (0, 0, 0))
screen.blit(text_5,(560,600))

pygame.display.flip()

seven_interval_Xaxis = [110,190,270,350,430,510,590,670]
six_interval_Yaxis = [120,200,280,360,440,520,600]
running = True
while running:  # 開啟一個事件循環處理發生的事件
  print("Train time:",train_time)
  original_state = screen.copy()
  train_time=train_time+1
  p_set=[]
  cpset=[]
  TFset=[]
  win_colset=[]
  N=np.zeros((6,7))
  #dice=random.randint(0,1)
  #dice=input("Do you want to go first?")
  print(dice)

  screen.blit(original_state, (0, 0))
  pygame.display.flip()

  if dice=='1':
    sign=0
    cp=Compute_point_2(N,0)
    cpset.append(cp)
    
    TF=True_false(N,0)           #盤面到哪裡必下哪裡不能下(凱威)  TF=[[1,2,3],[4,5,6]] 
    TFset.append(TF)
    win_col=Point_to_col(cp,TF)     #從分數以及必下不能下的點判斷下哪行-->給順位list來解決Q1? (晨洋)
    win_colset.append(win_col)
    #need fuction drop chess to 0,win_col[0]
    loc_x = (seven_interval_Xaxis[win_col[0]] + seven_interval_Xaxis[win_col[0] + 1])/2
    loc_y = six_interval_Yaxis[0] - (six_interval_Yaxis[1] - six_interval_Yaxis[0] )/2
    saved_state = screen.copy()
    for i in range(11):
      screen.blit(saved_state, (0, 0))
      pygame.draw.circle(screen, (205,39,45), (loc_x, loc_y), circle_radius, 0)
      pygame.display.flip()
      pygame.time.delay(50)
      loc_y = loc_y + (six_interval_Yaxis[-1] - six_interval_Yaxis[0])/10
    print("I want to lay down the chess on column",win_col[0]+1)
    N[0,win_col[0]]=1
    print(Visual(N))

    for ii in range(1,21):
      user = -1
      for event in pygame.event.get():
        do_nothing = 1
      choose_state = screen.copy()
      while(True):
        inner_break = 0
        mouse_pos = -1
        while(True):
          mouse_x, mouse_y = pygame.mouse.get_pos()

          if(mouse_pos != -1 and (seven_interval_Xaxis[mouse_pos] >= mouse_x or mouse_x >=seven_interval_Xaxis[mouse_pos+1])):
            screen.blit(choose_state, (0, 0))
            pygame.display.flip()
            mouse_pos = -1

          for i in range(7):
            if seven_interval_Xaxis[i] <= mouse_x and mouse_x <= seven_interval_Xaxis[i+1]:
              mouse_pos = i
          if(mouse_pos >-1):
            pygame.draw.rect(screen, (64,64,64), [seven_interval_Xaxis[mouse_pos], 0, rect_width, 600], 1) 
            pygame.display.flip()
          for event in pygame.event.get():
            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
              x, y = event.pos
              for i in range(7):
                if seven_interval_Xaxis[i] <= x and x <= seven_interval_Xaxis[i+1]:
                  user = i  
                  inner_break = 1    
          if(inner_break):
            break
        if(user != -1):
          break
      screen.blit(choose_state, (0, 0))
      pygame.display.flip()
      for k in range(0,6):            
        if N[k,user]==0:
          N[k,user]=2*ii
          col=user
          row=k
          break
      print(Visual(N))

      loc_x = (seven_interval_Xaxis[col] + seven_interval_Xaxis[col + 1])/2
      loc_y = six_interval_Yaxis[0] - (six_interval_Yaxis[1] - six_interval_Yaxis[0] )/2
      saved_state = screen.copy()
      for i in range(11):
        screen.blit(saved_state, (0, 0))
        pygame.draw.circle(screen, (44,41,198), (loc_x, loc_y), circle_radius, 0)
        pygame.display.flip()
        pygame.time.delay(50)
        loc_y = loc_y + (six_interval_Yaxis[5 - row + 1] - six_interval_Yaxis[0])/10

      if Check_win(N,row,col)!=0:             #檢查這步有沒有人贏 (凱威)
        Mset.append(N)              #有的話存盤面
        Wset.append(-1)   #有的話存盤面勝負
        sign=sign+1
        print("you win!")
        font = pygame.font.SysFont("Times New Roman", 80)
        # 创建文本对象
        text = font.render("You win!", True, (0, 0, 0))
        # 渲染文本到屏幕上
        screen.blit(text, (250, 30))
        pygame.display.flip()
        #end game
        event = pygame.event.wait()
        break

      #換電腦下
      cp=Compute_point_2(N,2*ii)         #盤面到分數(明宏)
      cpset.append(cp)
      TF=True_false(N,2*ii)           #盤面到哪裡必下哪裡不能下(凱威)  TF=[[1,2,3],[4,5,6]] 
      TFset.append(TF)
      win_col=Point_to_col(cp,TF)     #從分數以及必下不能下的點判斷下哪行-->給順位list來解決Q1? (晨洋)
      win_colset.append(win_col)

        
      flag=0
      for aa in range(0,7):
        for k in range(0,6):            #判斷確切下哪   ## Q1:如果不能下?
          if N[k,win_col[aa]]==0 and flag==0:
            N[k,win_col[aa]]=2*ii+1
            col=win_col[aa]
            row=k
            print("I want to lay down the chess on column",win_col[aa]+1)

            loc_x = (seven_interval_Xaxis[win_col[aa]] + seven_interval_Xaxis[win_col[aa] + 1])/2
            loc_y = six_interval_Yaxis[0]-(six_interval_Yaxis[1] - six_interval_Yaxis[0] )/2
            saved_state = screen.copy()
            for i in range(11):
              screen.blit(saved_state, (0, 0))
              pygame.draw.circle(screen, (205,39,45), (loc_x, loc_y),circle_radius, 0)
              pygame.display.flip()
              pygame.time.delay(50)
              loc_y = loc_y + (six_interval_Yaxis[5 - row + 1] - six_interval_Yaxis[0] )/10
            flag=flag+1
            break

      print(Visual(N))
      if Check_win(N,row,col)!=0:             #檢查這步有沒有人贏 (凱威)
        Mset.append(N)              #有的話存盤面
        Wset.append(1)   #有的話存盤面勝負
        print("You loss~")
        font = pygame.font.SysFont("Times New Roman", 80)
        # 创建文本对象
        text = font.render("You loss~", True, (0, 0, 0))
        # 渲染文本到屏幕上
        screen.blit(text, (250, 30))
        pygame.display.flip()
        #end game
        sign=sign+1
        break

    if sign==0:
      user = -1
      for event in pygame.event.get():
        do_nothing = 1
      choose_state = screen.copy()
      while(True):
        inner_break = 0
        mouse_pos = -1
        while(True):
          mouse_x, mouse_y = pygame.mouse.get_pos()

          if(mouse_pos != -1 and (seven_interval_Xaxis[mouse_pos] >= mouse_x or mouse_x >=seven_interval_Xaxis[mouse_pos+1])):
            screen.blit(choose_state, (0, 0))
            pygame.display.flip()
            mouse_pos = -1

          for i in range(7):
            if seven_interval_Xaxis[i] <= mouse_x and mouse_x <= seven_interval_Xaxis[i+1]:
              mouse_pos = i
          if(mouse_pos >-1):
            pygame.draw.rect(screen, (64,64,64), [seven_interval_Xaxis[mouse_pos], 0, rect_width, 600], 1) 
            pygame.display.flip()
          for event in pygame.event.get():
            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
              x, y = event.pos
              for i in range(7):
                if seven_interval_Xaxis[i] <= x and x <= seven_interval_Xaxis[i+1]:
                  user = i  
                  inner_break = 1    
          if(inner_break):
            break
        if(user != -1):
          break
      screen.blit(choose_state, (0, 0))
      pygame.display.flip()

      N[5,user]=42
      
      loc_x = (seven_interval_Xaxis[user] + seven_interval_Xaxis[user + 1])/2
      loc_y = six_interval_Yaxis[0] - (six_interval_Yaxis[1] - six_interval_Yaxis[0] )/2
      saved_state = screen.copy()
      for i in range(11):
        screen.blit(saved_state, (0, 0))
        pygame.draw.circle(screen, (44,41,198), (loc_x, loc_y), circle_radius, 0)
        pygame.display.flip()
        pygame.time.delay(50)
        loc_y = loc_y + (six_interval_Yaxis[1] - six_interval_Yaxis[0] )/10

      print(Visual(N))
      if Check_win(N,5,user)!=0:             #檢查這步有沒有人贏 (凱威)
        Mset.append(N)              #有的話存盤面
        Wset.append(-1)   #有的話存盤面勝負
        print("you win!")
        font = pygame.font.SysFont("Times New Roman", 80)
        # 创建文本对象
        text = font.render("You win!", True, (0, 0, 0))
        # 渲染文本到屏幕上
        screen.blit(text, (250, 30))
        pygame.display.flip()
        
        sign=sign+1
            
      #下完平手  
      if sign==0:
        Mset.append(N)                 
        Wset.append(0)
        print("Game drawn.")
        font = pygame.font.SysFont("Times New Roman", 80)
        # 创建文本对象
        text = font.render("Game drawn", True, (0, 0, 0))
        # 渲染文本到屏幕上
        screen.blit(text, (200, 30))
        pygame.display.flip()

  if dice=='0':                                                  #拿到0電腦後攻
    sign=0
    for ii in range(1,22):
      user = -1
      choose_state = screen.copy()
      for event in pygame.event.get():
        do_nothing = 1
      while(True):
        inner_break = 0
        mouse_pos = -1
        while(True):
          mouse_x, mouse_y = pygame.mouse.get_pos()

          if(mouse_pos != -1 and (seven_interval_Xaxis[mouse_pos] >= mouse_x or mouse_x >=seven_interval_Xaxis[mouse_pos+1])):
            screen.blit(choose_state, (0, 0))
            pygame.display.flip()
            mouse_pos = -1

          for i in range(7):
            if seven_interval_Xaxis[i] <= mouse_x and mouse_x <= seven_interval_Xaxis[i+1]:
              mouse_pos = i
          if(mouse_pos >-1):
            pygame.draw.rect(screen, (64,64,64), [seven_interval_Xaxis[mouse_pos], 0, rect_width, 600], 1) 
            pygame.display.flip()
          for event in pygame.event.get():
            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
              x, y = event.pos
              for i in range(7):
                if seven_interval_Xaxis[i] <= x and x <= seven_interval_Xaxis[i+1]:
                  user = i  
                  inner_break = 1    
          if(inner_break):
            break
        if(user != -1):
          break
      screen.blit(choose_state, (0, 0))
      pygame.display.flip()

      for k in range(0,6):            
        if N[k,user]==0:
          N[k,user]=2*ii-1
          col=user
          row=k
          break
      print(Visual(N))
      
      loc_x = (seven_interval_Xaxis[col] + seven_interval_Xaxis[col + 1])/2
      loc_y = six_interval_Yaxis[0] - (six_interval_Yaxis[1] - six_interval_Yaxis[0] )/2
      saved_state = screen.copy()
      for i in range(11):
        screen.blit(saved_state, (0, 0))
        pygame.draw.circle(screen, (44,41,198), (loc_x, loc_y), circle_radius, 0)
        pygame.display.flip()
        pygame.time.delay(50)
        loc_y = loc_y + (six_interval_Yaxis[5 - row + 1] - six_interval_Yaxis[0] )/10

      if Check_win(N,row,col)!=0:             #檢查這步有沒有人贏 (凱威)
        Mset.append(N)              #有的話存盤面
        Wset.append(1)   #有的話存盤面勝負
        print("you win!")
        font = pygame.font.SysFont("Times New Roman",80)
        # 创建文本对象
        text = font.render("You win!", True, (0, 0, 0))
        # 渲染文本到屏幕上
        screen.blit(text, (250, 30))
        pygame.display.flip()
        sign=sign+1
        break
        
      # 換電腦下 
      cp=Compute_point_2(N,2*ii-1)         #盤面到分數(明宏)
      cpset.append(cp)
      TF=True_false(N,2*ii-1)           #盤面到哪裡必下哪裡不能下(凱威)  TF=[[1,2,3],[4,5,6]] 
      TFset.append(TF)
      win_col=Point_to_col(cp,TF)     #從分數以及必下不能下的點判斷下哪行-->給順位list來解決Q1? (晨洋)
      win_colset.append(win_col)
        
      flag=0
      for aa in range(0,7):
        for k in range(0,6):            #判斷確切下哪   ## Q1:如果不能下?
          if N[k,win_col[aa]]==0 and flag==0:
            N[k,win_col[aa]]=2*ii
            col=win_col[aa]
            row=k
            print("I want to lay down the chess on column",win_col[aa]+1)
            flag=flag+1
            break

      print(Visual(N))
      loc_x = (seven_interval_Xaxis[col] + seven_interval_Xaxis[col + 1])/2
      loc_y = six_interval_Yaxis[0] - (six_interval_Yaxis[1] - six_interval_Yaxis[0] )/2
      saved_state = screen.copy()
      for i in range(11):
        screen.blit(saved_state, (0, 0))
        pygame.draw.circle(screen, (205,39,45), (loc_x, loc_y), circle_radius, 0)
        pygame.display.flip()
        pygame.time.delay(50)
        loc_y = loc_y + (six_interval_Yaxis[5 - row + 1] - six_interval_Yaxis[0] )/10

      if Check_win(N,row,col)!=0:             #檢查這步有沒有人贏 (凱威)
        Mset.append(N)              #有的話存盤面
        Wset.append(-1)   #有的話存盤面勝負
        print("you loss~")
        font = pygame.font.SysFont("Times New Roman", 80)
        # 创建文本对象
        text = font.render("You loss~", True, (0, 0, 0))
        # 渲染文本到屏幕上
        screen.blit(text, (250, 30))
        pygame.display.flip()
        sign=sign+1
        break
        
    if sign==0:
      Mset.append(N)                 
      Wset.append(0)
      print("draw~")
      font = pygame.font.SysFont("Times New Roman", 80)
      # 创建文本对象
      text = font.render("Game drawn~", True, (0, 0, 0))
      # 渲染文本到屏幕上
      screen.blit(text, (200, 30))
      pygame.display.flip()

  while True:
    event = pygame.event.wait()
    if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
      running = False
      break
